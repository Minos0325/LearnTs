// // // 应用测试
// 为TypeScript应用编写测试单元，使用工具和框架使测试更加便利。
// 要点：
    // 1、  建立基础测结构
    // 2、  测试规划和方法
    // 3、  如何使用 Mocha、Chai 和 Sinon.JS
    // 4、  如何使用断言、用例和套件
    // 5、  测试监视
    // 6、  测试桩
    // 7、  多环境测试
    // 8、  如何使用 Karma 和 PhantomJS
    // 9、  端对端测试
    // 10、 生成测试覆盖率报告
    // 入口：安装一些必要的第三方依赖开始。

// // 软件测试术语表
    // 断言：是一个条件，它是 必须被测试确认的一段代码的行为 是否与期望相符，换句话说是否与要求一致。
    // 案例：
        // 需求：Math.pow(base, exponent) 函数应该返回底数（base）的指数（exponent）次方（指数用来提升底数的幂————base^ exponent）。
        // 实现：
            // class Math1 {
            //     public static pow(base: number, exponent: number) {
            //         var result = base;
            //         for(var i= 1; i< exponent; i++) {
            //             result = result* base;
            //         }
            //         return result;
            //     }
            // }
        // ****************************************************
        // 为了确保这个方法被正确实现，我们必须测试它是否遵从需求。
        // 如果我们进一步分析需求，指数可以得到两个必要的断言。
            // 1、这个函数必须返回底数的指数幂：
                // var actual = Math1.pow(3, 5);
                // var expected = 243;
                // var asertion1 = (Math1.pow(base1, exponent1) === expected1);
            // 2、底数没有被用作指数（或指数没有被用作底数）
                // var actual = Math1.pow(5, 3);
                // var expected = 125;
                // var asertion2 = (Math1.pow(base2, exponent2) === expected2);
            // 如果两个断言都合法，那代码都是满足需求的，并且我们知道它会如预期那样工作：
                // var isValidCode = (asertion1 && asertion2);
                // console.log(isValidCode);
        // ****************************************************

// // 测试规范 specs
    // 测试规范（specs）是软件开发人员用来指代测试规范的一个术语。
    // 一个测试规范（不要和测试计划混淆）是一个详细的清单：
    //     它包含了需要测试的场景，这些场景将如何被测试，它们应该怎样被测试等。

// // 测试用例
    // 测试用例 是决定一个程序中的功能 是否按照 原始期望 工作的一些条件。
    // 断言是 一个条件， 测试用例 是一组条件。

// // 测试套件
    // 一个 测试套件 是许多 测试用例 的集合。
    // 测试用例只是针对某一个具体的测试场景，一个测试套件可以包含多个测试用例来覆盖很多测试场景。

// // 测试监视
    // 测试监视（Spy）是 某些测试框架提供的功能。它允许我们包裹一个函数，并且记录它的使用情况（输入，输出，被调用次数）。
    // 当用syp包裹一个函数时，这个函数的功能并没有被改变。

// // 替身
    // 替身对象 指 测试执行时 被 传入 但并没有实际 用到的对象。

// // 测试桩
    // 桩（stub）是测试框架提供的一种功能。测试桩也允许包裹一个方法然后 观察它的使用情况。
    // 和 测试监测 不一样的是，当使用测试桩 包裹一个函数时，这个函数的功能会被新的行为替换。

// // 模拟
    // 模拟（mock） 很容易和 测试桩（stub）混淆。
    // 区别：模拟（mock）和 测试桩（stub）
        // 1、测试结果的验证方式不同，一个是状态验证， 一个是行为验证
        // 2、测试与设计哲学完全不同，一个是传统型的， 一个是测试驱动开发的mockist（mock风格）的。
    // 详见书末尾、

// // 测试覆盖率
    // 指 程序中有多大比例的代码通过自动化测试被测试到。


// // // 实践
// ************************************************************
// 必要的准备
    // npm工具
    // gulp (任务运行器)
    // Karma (测试运行器)
    // Istanbul ：是指出哪一行代码在自动化测试中被测试到的工具，可以生成测试覆盖率报告。一般建议至少75%以上，开源项目目标都是100%的
    // Mocha ：JavaScript测试框架库，能方便地创建测试套件、测试用例、测试规范。
                // 可在前端或后台测试 TypeScript，指出性能问题，生成不同类型报告等，功能还有很多。
    // Chai ：是一个支持 测试驱动开发(TDD) 和 行为驱动开发（BDD）测试 的断言库。
                // 主要功能是减少测试断言需要的工作量，并且使测试更可读。
    // Sinon.js ：是一个独立的框架，它提供了一组API（测试监视、测试桩、测试模拟），可以帮我们独立地测试一个组件。
                // 独立的测试 软件模块很困难，因为通常模块之间有着很高程度的耦合，但通过Sinon.js这种模拟框架就可以做到。


    // PhantomJS: 是一个无显示界面的浏览器。可以通过PhantomJS运行浏览器测试而不需要真正地开启浏览器。
        // 优势：    
            // 1、PhantomJS可以通过命令行执行，使它非常容易与任务运行器和持续集成服务集成。
            // 2、不必打开浏览器潜在地减少了完成测试套件所需要的时间。

    // Selenium 和 Nightwatch.js:
        // Selenium 是 一个测试运行器，但 它被特别设计只运行叫做端对端（E2E）测试的特定的测试。
        // 我们不直接使用Selenium
        // Nightwatch.js是工具，其会自动运行 Selenium
        // Nightwatch.js是一个自动化测试框架，使用 Node.js开发Web程序和网站，它使用了 Selenium网络驱动API，是一个完整的 浏览器（E2E）测试解决方案

    // ***** 代码见 cs文件夹 ***** 

// 步骤：
    // 新建文件夹
    // npm init：生成 package.json
    // npm install gulp -g：安装gulp
    // npm install --save-dev karma ：安装 karma
    // npm install --save-dev karma-coverage ：安装 karma 插件，便于创建测试覆盖率报告
    // npm install --save-dev mocha karma-mocha ： 安装Mocha 和 Karma-Mocha插件。
    // npm install --save-dev chai karma-chai ： 安装 Chai 和 Karma-Chai插件。
    // npm install --save-dev sinon karma-sinon ：安装Sinon.js 和 karma-sinon插件
    
    // npm install -g tsd ：工具命令安装
    // tsd init ：初始化
    // 引入类型定义
        // tsd install mocha --save 
        // tsd install chai --save 
        // tsd install sinon --save 
        // tsd install jquery --save 
    
    // npm install --save-dev phantomjs ： 安装phantomjs
    // npm install --save-dev karma-phantomjs-launcher ： 安装运行在 phantomjs中的 karma 插件

    // *** *** 安装 Selenium 和 Nigthwatch.js *** ***
        // npm install --save-dev gulp-nightwatch ： 
        // npm install selenium-standalone -g ： 
        // selenium-standalone install ： 
        // *** selenium-standalone 需要 java 的二进制文件被安装到开发环境中，并可以通过$PATH环境变量访问到
    // *** *** 安装 Selenium 和 Nigthwatch.js *** ***
// **** tsd 应用  见第二章 ****
// ************************************************************

// // 测试计划和方法
    // 主要有两种 风格 或 方法 可选： 测试驱动开发(TDD) 和 行为驱动开发(BDD)。

// 测试驱动开发(TDD)：是一种测试技术，它鼓励开发者在写程序代码之前写测试。
    // 通常情况下 TDD编码 包含的基本步骤：
        // 1、编写一个不通过的测试。
        // 2、运行这个测试，并保证它不通过（无任何程序代码。 所以测试应该无法通过）
        // 3、编写应用代码，让测试通过。
        // 4、运行这个测试，保证它能通过。
        // 5、运行所有其他测试，保证程序的其他部分没有被破坏
        // 6、重复以上步骤
    // TDD 是被推荐的，会极大的增加程序的测试覆盖率，并因此显著减少错误数量。

// 行为驱动开发(BDD)：是在测试驱动开发后出现，它的使命是提取 TDD 的精华。
    // 以BDD的方式测试的重点是描述并阐明测试应该关注程序的需求 而非 测试的需求。
    // 理想状态下，它会鼓励开发者少思考测试这件事情本身 而 更多地思考整个程序。

// Mocha 和 Chai 提供了 一些 API 给 BDD 和 TDD 方法。
// BDD 是 优化后的 TDD， BDD容易被客户理解。BDD还被用于记录能被客户和开发者理解与验证的需求。

// // 测试计划 和 测试类型
    // *** 测试计划 不是 测试规范， 不能指代 测试规范。
    // 测试规范： 用来定义 有 哪些场景会被测试， 怎样被测试。
    // 测试计划： 是特定被测试区域内的测试规范的集合。

// 一般推荐为具体的测试计划撰写文档，因为一个测试计划包括非常多的步骤、文档和实践。
// 测试计划的一个重要目标是， 定义、指出什么类型的测试对于程序中的特定组件是合格的。

// 最常用的测试 类型：
    // 单元测试：单元测试被用来测试 独立的组件，如果不是独立的（包含依赖）就需要 通过设置测试模拟 和 依赖这个注入来尽可能地让它在测试中独立。
            // 如果没办法操作组件的依赖，则使用测试监视以 让测试更加方便。
        // 单元测试目标： 应达到 组件完全独立的程度。
        // 一个单元测试也应该需要凯苏运行，一个避免输入输出、网络请求，或任何可能影响到测试运行速度的操作。
    // 部分集成测试和整体集成测试： 被用来测试一组组件（部分集成测试），或 整个程序（整体集成测试）。
            // 集成测试中，正常使用已知数据与后端通信，获取到将会显示在前端的数据，随后我们断言显示的信息是否是正确的。
    // 回归测试：用来确认程错误是否被修复。如果使用 BDD 或 TDD，当遇到一个程序错误时，应新建一个单元测试来重现这个问题，
            // 然后改写代码。做完这些就可以运行单元测试尝试重现错误并通过测试，最后确认所有测试都能正常通过。
    // 性能/加载测试：用来确认程序是否到达性能预期。
            // 可以使用性能测试确认程序是否能处理大量的用户并发或活跃度剧增。    
    // 端对端（E2E）测试：这种测试和整体集成测试其实并没有什么不同。主要区别是在一个E2E测试活动期间，我们会尝试完全模拟与正式用户一样的环境。
            // 为了达到这个目的，将使用 Nightwatch.js 和 Selenium。
    // 验收测试（UAT）：这被用来验证 系统 是否符合用户所有需求。


// // // 建立测试基础结构
// 组件独立：遵循 依赖反转原则 增加 组件之间的分离度，使程序各个组件 保持独立。
// 使用Gulp 和 Karma 设置一个测试环境并使用 Mocha 和 Chai编写一些自动化测试。

// 详细代码见 书P193 +